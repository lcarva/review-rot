#!/usr/bin/env python
import logging
import operator
import datetime
import os
import importlib_resources
import sys

from reviewrot.basereview import BaseReview
from reviewrot import (
    GerritService,
    get_git_service,
    get_arguments,
    load_config_file,
    parse_cli_args,
    CHOICES,
    DEFAULT_SUBJECT,
    remove_wip,
)

try:
    import urllib.parse as urllib  # Python 3
except ImportError:
    import urllib  # Python 2

format_duration = BaseReview.format_duration

log = logging.getLogger(__name__)

# Characters to include at the beginning and end of reports
report_prefixes = {"oneline": "", "indented": "", "json": "["}
report_suffixes = {"oneline": "", "indented": "", "json": "]"}


def _get_token(item):
    """Extract token from config, or environment as necessary."""
    token = item.get("token")
    # Support pulling a token from an environment variable
    # If the token value starts with "ENV.", then the value
    # for the token will be pulled from the environment variable
    # specified following "ENV."
    # For example, if the token value specified in the config is
    # "ENV.FOO", then the real value for the environment variable
    # will be taken from the environment variable "FOO"
    if token and token.startswith("ENV."):
        token_env_var = token.split("ENV.")[1]
        token = os.environ.get(token_env_var)
    return token


def is_automated_pr(user, automated_users=None):
    """
    Check if the user is a known automation bot.

    Args:
        user (str): Username to check
        automated_users (list, optional): List of automated users/bots from configuration.
                                        If not provided, uses default hardcoded list.

    Returns:
        bool: True if the user is an automated bot, False otherwise
    """
    # Default list for backward compatibility
    default_automated_bots = [
        "renovate[bot]",
        "dependabot[bot]",
        "red-hat-konflux[bot]",
        "ec-automation[bot]",
    ]

    # Use configured list if provided, otherwise fall back to default
    bots_to_check = (
        automated_users if automated_users is not None else default_automated_bots
    )

    if not user:
        return False

    user_lower = user.lower()
    return any(bot.lower() in user_lower for bot in bots_to_check)


def main():
    """
    Reads arguments from CLI and configuration file.
    Calls appropriate git service with suitable inputs.
    """

    cli_args = parse_cli_args(sys.argv[1:])
    config = load_config_file(cli_args.config)

    arguments = get_arguments(
        cli_args,
        config,
    )

    if arguments.get("debug"):
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    results = []
    for item in config.get("git_services", []):
        if "type" not in item:
            log.debug("git service type not found for %s", item)
            raise KeyError("git service not found for %s" % item)

        # get git service
        git_service = get_git_service(item["type"])

        # Reviewers config for Gerrit service only
        if type(git_service) == GerritService:
            reviewers_config = item.get("reviewers")
        else:
            reviewers_config = None

        current_service_results = []
        """
        check if username and/or repository information is given for
        specified git service
        """
        if item["repos"] is not None:
            # for each input call specified git service
            for data in item["repos"]:
                """
                split and format username and repository name to further
                request pull requests.
                """
                res = format_user_repo_name(data, git_service)
                """
                get pull/merge/change requests for specified git service
                """
                service_reviews = git_service.request_reviews(
                    user_name=res.get("user_name"),
                    repo_name=res.get("repo_name"),
                    age=arguments.get("age"),
                    show_last_comment=arguments.get("show_last_comment"),
                    token=_get_token(item),
                    host=remove_trailing_slash_from_url(item.get("host")),
                    ssl_verify=arguments.get("ssl_verify"),
                    reviewers_config=reviewers_config,
                    labels=item.get("labels"),
                )
                current_service_results.extend(service_reviews)

        # Mark reviews as automated if categorize_automated is enabled
        if arguments.get("categorize_automated"):
            automated_users = item.get("automated_users")
            for result in current_service_results:
                result.is_automated = is_automated_pr(result.user, automated_users)

        results.extend(current_service_results)

    if arguments.get("ignore_wip"):
        results = remove_wip(results)

    # With the --sort argument, --comment-sort is kept for backwards
    # compatibility. Equivalent to --sort commented
    if arguments.get("comment_sort"):
        arguments["sort"] = "commented"

    # Now, with all results in place, sort them and print
    # If sort is not passed or not provided as configuration argument, use the
    # first element of the sort choices list as default.
    sort_by = arguments.get("sort", CHOICES["sort"][0])

    if sort_by == "commented":
        sorting_key = sort_by_last_comment
    else:
        sort_index = {
            "submitted": "time",
            "updated": "updated_time",
        }
        sort_attr = sort_index.get(sort_by)

        # As sort_index has to be explicitly matched, ensure that is kept in
        # sync with sort choices list.
        if sort_attr is None:
            error_message = "Sort by {} not supported".format(sort_by)
            log.debug(error_message)
            raise ValueError(error_message)

        sorting_key = operator.attrgetter(sort_attr)

    sorted_results = sorted(
        results,
        key=sorting_key,
        reverse=arguments.get("reverse"),
    )
    formatting = arguments.get("format", "oneline")

    if sorted_results:
        output_file = arguments.get("output")
        if not output_file:
            print(report_prefixes[formatting])
            for i, result in enumerate(sorted_results):
                print(
                    result.format(
                        style=formatting,
                        i=i,
                        n=len(results),
                        show_last_comment=arguments.get("show_last_comment"),
                    )
                )
            print(report_suffixes[formatting])
        else:
            # TODO: Please be smarter about this...
            with open(output_file, "w") as f:
                print(report_prefixes[formatting], file=f)
                for i, result in enumerate(sorted_results):
                    print(
                        result.format(
                            style=formatting,
                            i=i,
                            n=len(results),
                            show_last_comment=arguments.get("show_last_comment"),
                        ),
                        file=f,
                    )
                print(report_suffixes[formatting], file=f)


def sort_by_last_comment(result):
    """
    Helper function for sorting by last comment date

    Args:
        result (reviewrot.basereview.Basereview):
        Instance containing data about review

    Returns:
        last comment date (datetime.datetime): when available or
        default datetime.datetime with MAX value
    """

    if result.last_comment:
        return result.last_comment.created_at
    # if result does not contain last comment, return default datetime
    # with maximum value
    return datetime.datetime.combine(datetime.date.max, datetime.datetime.min.time())


def remove_trailing_slash_from_url(url):
    """
    Helper function for removing trailing slash from url

    Args:
        url (string): url

    Returns:
        url (string) url without trailing slash
    """
    if url:
        if url.endswith("/"):
            return url[:-1]
        return url


def format_user_repo_name(data, git_service):
    """
    Takes input from configuration file for a specified git service.
    Split or format it as required.
    Args:
        data (str): combination of username and/or reponame
        git_service (BaseService) : Git service object
    Returns:
        Dictionary representation of username and reponame
    """
    user_name = None
    repo_name = None

    if isinstance(git_service, GerritService):
        # convert "/" if any into escape character for html request
        repo_name = urllib.quote_plus(data)
    elif "/" in data:
        # Splitting only once in case "/" is a valid character in the data.
        user_name, repo_name = data.split("/", 1)
    else:
        user_name = data

    return {"user_name": user_name, "repo_name": repo_name}


if __name__ == "__main__":
    main()
